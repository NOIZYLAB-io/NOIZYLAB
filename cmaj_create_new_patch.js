//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  The Cmajor project is subject to commercial or open-source licensing.
//  You may use it under the terms of the GPLv3 (see www.gnu.org/licenses), or
//  visit https://cmajor.dev to learn about our commercial licence options.
//
//  CMAJOR IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
//  EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
//  DISCLAIMED.

const vscode  = require('vscode');
const helpers = require ("./cmaj_helpers.js");

const patchManifest = `
{
    "CmajorVersion":    1,
    "ID":               "com.your_name.your_patch_ID",
    "version":          "1.0",
    "name":             "NAME",
    "description":      "NAME",
    "category":         "generator",
    "manufacturer":     "Your Company Goes Here",
    "isInstrument":     true,

    "source":           "NAME.cmajor"
}
`;

const patchManifestWithGUI = `
{
    "CmajorVersion":    1,
    "ID":               "com.your_name.your_patch_ID",
    "version":          "1.0",
    "name":             "NAME",
    "description":      "NAME",
    "category":         "generator",
    "manufacturer":     "Your Company Goes Here",
    "isInstrument":     true,

    "source":           "NAME.cmajor",

    "view":             { "src": "view/index.js",
                          "width": 500,
                          "height": 300,
                          "resizable": true }
}
`;

const patchCode = `
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/

// Here's a very simple graph that plays a sine-wave to get you started..
processor NAME  [[ main ]]
{
    output stream float out;
    input value float frequency [[ name: "Frequency", min: 5.0f, max: 1000.0f, init: 440.0f ]];

    // This is our processor's entry-point function, which is invoked
    // by the system
    void main()
    {
        loop
        {
            out <- volume * sin (phase);

            let phaseDelta = float (frequency * processor.period * twoPi);
            phase = addModulo2Pi (phase, phaseDelta);
            advance();
        }
    }

    let volume = 0.15f;
    float phase;
}
`;

const demoGUICode = `

/*
    This simple web component just manually creates a set of plain sliders for the
    known parameters, and uses some listeners to connect them to the patch.
*/
class NAME_View extends HTMLElement
{
    constructor (patchConnection)
    {
        super();
        this.patchConnection = patchConnection;
        this.classList = "main-view-element";
        this.innerHTML = this.getHTML();
    }

    connectedCallback()
    {
        // When the HTMLElement is shown, this is a good place to connect
        // any listeners you need to the PatchConnection object..

        // First, find our frequency slider:
        const freqSlider = this.querySelector ("#frequency");

        // When the slider is moved, this will cause the new value to be sent to the patch:
        freqSlider.oninput = () => this.patchConnection.sendEventOrValue (freqSlider.id, freqSlider.value);

        // Create a listener for the frequency endpoint, so that when it changes, we update our slider..
        this.freqListener = value => freqSlider.value = value;
        this.patchConnection.addParameterListener (freqSlider.id, this.freqListener);

        // Now request an initial update, to get our slider to show the correct starting value:
        this.patchConnection.requestParameterValue (freqSlider.id);
    }

    disconnectedCallback()
    {
        // When our element is removed, this is a good place to remove
        // any listeners that you may have added to the PatchConnection object.
        this.patchConnection.removeParameterListener ("frequency", this.freqListener);
    }

    getHTML()
    {
        return \`
        <style>
            .main-view-element {
                background: #bcb;
                display: block;
                width: 100%;
                height: 100%;
                padding: 10px;
                overflow: auto;
            }

            .param {
                display: inline-block;
                margin: 10px;
                width: 300px;
            }
        </style>

        <div id="controls">
          <p>Your GUI goes here!</p>
          <input type="range" class="param" id="frequency" min="5" max="1000">Frequency</input>
        </div>\`;
    }
}

window.customElements.define ("VIEWNAME", NAME_View);

/* This is the function that a host (the command line patch player, or a Cmajor plugin
   loader, or our VScode extension, etc) will call in order to create a view for your patch.

   Ultimately, a DOM element must be returned to the caller for it to append to its document.
   However, this function can be \`async\` if you need to perform asyncronous tasks, such as
   fetching remote resources for use in the view, before completing.
*/
export default function createPatchView (patchConnection)
{
    return new NAME_View (patchConnection);
}
`;


async function createNewPatch()
{
    const createGUIOptions = ["Create a new patch with a demo GUI",
                              "Create a new patch without a GUI"];

    const createGUI = await vscode.window.showQuickPick (createGUIOptions, { canPickMany: false });

    if (! createGUI)
        return;

    const shouldCreateGUI = (createGUI === createGUIOptions[0]);

    const manifestFile = await vscode.window.showSaveDialog ({
        title: "Choose the file to create for a new Cmajor Patch",
        saveLabel: "Create Patch",
        filters: { "Cmajor Patch": [ "cmajorpatch"] }
    });

    if (manifestFile)
    {
        if (! helpers.isPatchFile (manifestFile))
        {
            vscode.window.showErrorMessage ("Cmajor: A patch file must have the extension '.cmajorpatch'");
            return;
        }

        const fileName = helpers.getFilenameStem (manifestFile.fsPath).trim();
        const className = helpers.makeSafeIdentifier (fileName);

        const codeFile = helpers.getSibling (manifestFile, fileName + ".cmajor");

        const manifest = (shouldCreateGUI ? patchManifestWithGUI : patchManifest)
                            .replaceAll ("NAME", fileName);

        const code = patchCode.replaceAll ("NAME", className);

        const guiFile = vscode.Uri.joinPath (helpers.getSibling (manifestFile, "view"), "/index.js");

        await helpers.writeToFile (manifestFile, manifest);
        await helpers.writeToFile (codeFile, code);

        if (shouldCreateGUI)
        {
            await helpers.writeToFile (guiFile, demoGUICode.replaceAll ("VIEWNAME", className.toLowerCase() + "-view")
                                                           .replaceAll ("NAME", className));
        }

        if (vscode.workspace.workspaceFolders)
        {
            if (shouldCreateGUI)
                await vscode.window.showTextDocument (guiFile, { preview: false });

            await vscode.window.showTextDocument (codeFile, { preview: false });
            await vscode.window.showTextDocument (manifestFile, { preview: false });
        }
        else
        {
            return vscode.commands.executeCommand ('vscode.openFolder', helpers.getParentPath (manifestFile),
            {
                forceNewWindow: true,
                noRecentEntry: true
            });
        }
    }
}

module.exports = {
    createNewPatch
}
