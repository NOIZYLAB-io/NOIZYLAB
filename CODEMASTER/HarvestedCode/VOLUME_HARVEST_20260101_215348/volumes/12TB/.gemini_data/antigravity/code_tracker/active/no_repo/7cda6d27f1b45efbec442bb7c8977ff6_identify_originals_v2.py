Àimport os
import wave
import struct

ROOT_DIR = "/Volumes/6TB/Sample_Libraries"
REPORT_FILE = "/Users/m2ultra/.gemini/robs_originals_report.md"

originals = []
commercial = []

print(f"üïµÔ∏è‚Äç‚ôÄÔ∏è CB_01 AUDIO DETECTIVE STARTING (Manual Header Parsing)...")
print(f"Target: Detect 24-bit (ROB) vs 16-bit (Commercial) in {ROOT_DIR}")

def get_wav_depth(path):
    try:
        with wave.open(path, 'rb') as f:
            return f.getsampwidth() * 8
    except:
        return None

def get_aiff_depth(path):
    try:
        with open(path, 'rb') as f:
            header = f.read(12)
            if header[:4] != b'FORM' or header[8:12] not in [b'AIFF', b'AIFC']:
                return None
            
            # Walk chunks
            while True:
                chunk_header = f.read(8)
                if len(chunk_header) < 8: break
                
                chunk_id = chunk_header[:4]
                chunk_size = struct.unpack('>I', chunk_header[4:])[0]
                
                if chunk_id == b'COMM':
                    # COMM chunk found
                    # numChannels (2), numSampleFrames (4), sampleSize (2)
                    data = f.read(8) 
                    # We just read 8 bytes: channels(2) + frames(4) + next is bitDepth(2) -- Wait
                    # channels (2 bytes), frames (4 bytes), sampleSize (2 bytes) = 8 bytes total up to bitdepth?
                    # No: 2+4 = 6 bytes.
                    # channels: 0-1
                    # frames: 2-5
                    # sampleSize: 6-7
                    sample_size_data = data[6:8]
                    bit_depth = struct.unpack('>h', sample_size_data)[0]
                    return bit_depth
                else:
                    # Skip chunk
                    f.seek(chunk_size, 1)
                    # Handle padding byte if size is odd
                    if chunk_size % 2 != 0:
                        f.read(1)
    except Exception as e:
        # print(f"Error reading {path}: {e}")
        return None
    return None

def get_bit_depth(file_path):
    ext = os.path.splitext(file_path)[1].lower()
    if ext == '.wav':
        return get_wav_depth(file_path)
    elif ext in ['.aif', '.aiff']:
        return get_aiff_depth(file_path)
    return None

count = 0
for root, dirs, files in os.walk(ROOT_DIR):
    for file in files:
        path = os.path.join(root, file)
        depth = get_bit_depth(path)
        
        if depth:
            if depth >= 24:
                originals.append(path)
            elif depth == 16:
                commercial.append(path)
            
        count += 1
        if count % 1000 == 0:
            print(f"Processed {count} files...")

print(f"\n‚úÖ ANALYSIS COMPLETE")
print(f"Found {len(originals)} potential ORIGINAL ROB RECORDINGS (24-bit+)")
print(f"Found {len(commercial)} COMMERCIAL SAMPLES (16-bit)")

# Generate Report
report = f"""# üéµ ROB'S ORIGINAL WORKS REPORT (UPDATED)
**Generated by:** CB_01
**Source:** `{ROOT_DIR}`
**Method:** Binary Header Analysis (AIFF/WAV)

## üíé POTENTIAL ORIGINALS (24-Bit+ Audio)
**Count:** {len(originals)}

"""

if originals:
    # List first 50
    originals.sort()
    for path in originals[:50]:
        report += f"- `{os.path.basename(path)}`\n"
    
    if len(originals) > 50:
        report += f"\n...and {len(originals) - 50} more."
else:
    report += "No 24-bit files found in this directory."

with open(REPORT_FILE, "w") as f:
    f.write(report)

print(f"üìÑ Report saved to {REPORT_FILE}")
À*cascade0826file:///Users/m2ultra/.gemini/identify_originals_v2.py