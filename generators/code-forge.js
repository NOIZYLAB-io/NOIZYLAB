// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CODE FORGE - THE ULTIMATE CODE GENERATION FACTORY
// Generates any type of code from specifications
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class CodeForge {
  constructor(ai = null) {
    this.ai = ai;
    this.templates = new Map();
    this.history = [];

    this.registerTemplates();
  }

  // â”€â”€â”€ TEMPLATE REGISTRATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  registerTemplates() {
    // Cloudflare Worker
    this.templates.set("worker", {
      name: "Cloudflare Worker",
      description: "Edge computing worker with fetch handler",
      generate: (spec) => this.generateWorker(spec)
    });

    // REST API
    this.templates.set("api", {
      name: "REST API",
      description: "Full REST API with CRUD operations",
      generate: (spec) => this.generateAPI(spec)
    });

    // CLI Tool
    this.templates.set("cli", {
      name: "CLI Tool",
      description: "Command-line interface application",
      generate: (spec) => this.generateCLI(spec)
    });

    // React Component
    this.templates.set("component", {
      name: "React Component",
      description: "React functional component with hooks",
      generate: (spec) => this.generateComponent(spec)
    });

    // Express Server
    this.templates.set("server", {
      name: "Express Server",
      description: "Node.js Express server",
      generate: (spec) => this.generateServer(spec)
    });

    // Database Model
    this.templates.set("model", {
      name: "Database Model",
      description: "Database model with schema",
      generate: (spec) => this.generateModel(spec)
    });

    // Test Suite
    this.templates.set("test", {
      name: "Test Suite",
      description: "Comprehensive test suite",
      generate: (spec) => this.generateTest(spec)
    });

    // Full Project
    this.templates.set("project", {
      name: "Full Project",
      description: "Complete project scaffold",
      generate: (spec) => this.generateProject(spec)
    });
  }

  // â”€â”€â”€ MAIN GENERATION METHOD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async forge(type, spec = {}) {
    const template = this.templates.get(type);

    if (!template) {
      throw new Error(`Unknown template type: ${type}. Available: ${Array.from(this.templates.keys()).join(", ")}`);
    }

    const result = await template.generate(spec);

    this.history.push({
      type,
      spec,
      timestamp: new Date().toISOString(),
      files: result.files?.length || 1
    });

    return result;
  }

  // â”€â”€â”€ GENERATOR IMPLEMENTATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  generateWorker(spec) {
    const { name = "worker", routes = [], kv = false, ai = false, email = false } = spec;

    let code = `// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name.toUpperCase()} - Cloudflare Worker
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;

    // CORS headers
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Content-Type": "application/json"
    };

    if (method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    try {
`;

    // Add routes
    if (routes.length > 0) {
      routes.forEach(route => {
        code += `
      // ${route.description || route.path}
      if (path === "${route.path}" && method === "${route.method || "GET"}") {
        ${route.handler || `return json({ message: "${route.path} handler" });`}
      }
`;
      });
    } else {
      code += `
      // Health check
      if (path === "/" || path === "/health") {
        return json({ status: "ok", worker: "${name}", timestamp: new Date().toISOString() });
      }
`;
    }

    code += `
      // 404 Not Found
      return json({ error: "Not Found", path }, 404);

    } catch (error) {
      return json({ error: error.message }, 500);
    }
  }`;

    // Add email handler if needed
    if (email) {
      code += `,

  async email(message, env, ctx) {
    const from = message.from;
    const to = message.to;
    const subject = message.headers.get("subject");

    // Process email
    console.log(\`Email from \${from}: \${subject}\`);

    // Forward email
    await message.forward(env.FORWARD_EMAIL || "admin@example.com");
  }`;
    }

    code += `
};

// Helper function
function json(data, status = 200) {
  return new Response(JSON.stringify(data, null, 2), {
    status,
    headers: { "Content-Type": "application/json" }
  });
}
`;

    return {
      type: "worker",
      name,
      files: [{ path: `workers/${name}.js`, content: code }],
      config: this.generateWranglerConfig(name, { kv, ai })
    };
  }

  generateAPI(spec) {
    const { name = "api", resources = [], auth = false } = spec;

    let code = `// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name.toUpperCase()} - REST API
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CORS_HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-API-Key",
  "Content-Type": "application/json"
};

export default {
  async fetch(request, env, ctx) {
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: CORS_HEADERS });
    }

    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;
`;

    if (auth) {
      code += `
    // Authentication
    const apiKey = request.headers.get("X-API-Key");
    if (env.REQUIRE_AUTH === "true" && apiKey !== env.API_KEY) {
      return json({ error: "Unauthorized" }, 401);
    }
`;
    }

    code += `
    try {
      // API Routes
      const router = new Router();
`;

    // Generate CRUD for each resource
    resources.forEach(resource => {
      const singular = resource.name;
      const plural = resource.plural || `${singular}s`;

      code += `
      // â”€â”€â”€ ${plural.toUpperCase()} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      router.get("/${plural}", () => list${capitalize(plural)}(env));
      router.get("/${plural}/:id", (params) => get${capitalize(singular)}(env, params.id));
      router.post("/${plural}", (params, body) => create${capitalize(singular)}(env, body));
      router.put("/${plural}/:id", (params, body) => update${capitalize(singular)}(env, params.id, body));
      router.delete("/${plural}/:id", (params) => delete${capitalize(singular)}(env, params.id));
`;
    });

    code += `
      // Health check
      router.get("/", () => ({ status: "ok", api: "${name}", version: "1.0.0" }));
      router.get("/health", () => ({ status: "ok", timestamp: new Date().toISOString() }));

      // Execute route
      const result = await router.handle(method, path, request);
      return json(result);

    } catch (error) {
      return json({ error: error.message }, error.status || 500);
    }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Router {
  constructor() {
    this.routes = [];
  }

  get(path, handler) { this.routes.push({ method: "GET", path, handler }); }
  post(path, handler) { this.routes.push({ method: "POST", path, handler }); }
  put(path, handler) { this.routes.push({ method: "PUT", path, handler }); }
  delete(path, handler) { this.routes.push({ method: "DELETE", path, handler }); }

  async handle(method, path, request) {
    for (const route of this.routes) {
      if (route.method !== method) continue;

      const params = this.match(route.path, path);
      if (params !== null) {
        const body = method !== "GET" ? await request.json().catch(() => ({})) : {};
        return route.handler(params, body);
      }
    }
    const error = new Error("Not Found");
    error.status = 404;
    throw error;
  }

  match(pattern, path) {
    const patternParts = pattern.split("/");
    const pathParts = path.split("/");

    if (patternParts.length !== pathParts.length) return null;

    const params = {};
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(":")) {
        params[patternParts[i].slice(1)] = pathParts[i];
      } else if (patternParts[i] !== pathParts[i]) {
        return null;
      }
    }
    return params;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESOURCE HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

    // Generate handlers for each resource
    resources.forEach(resource => {
      const singular = resource.name;
      const plural = resource.plural || `${singular}s`;
      const cap = capitalize(singular);
      const capPlural = capitalize(plural);

      code += `
// â”€â”€â”€ ${plural.toUpperCase()} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function list${capPlural}(env) {
  const data = await env.KV?.get("${plural}", "json") || [];
  return { ${plural}: data, count: data.length };
}

async function get${cap}(env, id) {
  const data = await env.KV?.get("${plural}", "json") || [];
  const item = data.find(i => i.id === id);
  if (!item) {
    const error = new Error("${cap} not found");
    error.status = 404;
    throw error;
  }
  return item;
}

async function create${cap}(env, body) {
  const data = await env.KV?.get("${plural}", "json") || [];
  const item = {
    id: \`${singular}-\${Date.now()}\`,
    ...body,
    createdAt: new Date().toISOString()
  };
  data.push(item);
  await env.KV?.put("${plural}", JSON.stringify(data));
  return item;
}

async function update${cap}(env, id, body) {
  const data = await env.KV?.get("${plural}", "json") || [];
  const index = data.findIndex(i => i.id === id);
  if (index === -1) {
    const error = new Error("${cap} not found");
    error.status = 404;
    throw error;
  }
  data[index] = { ...data[index], ...body, updatedAt: new Date().toISOString() };
  await env.KV?.put("${plural}", JSON.stringify(data));
  return data[index];
}

async function delete${cap}(env, id) {
  const data = await env.KV?.get("${plural}", "json") || [];
  const index = data.findIndex(i => i.id === id);
  if (index === -1) {
    const error = new Error("${cap} not found");
    error.status = 404;
    throw error;
  }
  const [deleted] = data.splice(index, 1);
  await env.KV?.put("${plural}", JSON.stringify(data));
  return { deleted: true, item: deleted };
}
`;
    });

    code += `
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function json(data, status = 200) {
  return new Response(JSON.stringify(data, null, 2), {
    status,
    headers: CORS_HEADERS
  });
}
`;

    return {
      type: "api",
      name,
      files: [{ path: `workers/${name}-api.js`, content: code }],
      config: this.generateWranglerConfig(name, { kv: true })
    };
  }

  generateCLI(spec) {
    const { name = "mycli", commands = [], description = "A CLI tool" } = spec;

    let code = `#!/usr/bin/env node
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name.toUpperCase()} CLI
// ${description}
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { execSync } from "child_process";
import fs from "fs";
import path from "path";

// â”€â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const C = {
  reset: "\\x1b[0m",
  bright: "\\x1b[1m",
  dim: "\\x1b[2m",
  red: "\\x1b[31m",
  green: "\\x1b[32m",
  yellow: "\\x1b[33m",
  blue: "\\x1b[34m",
  magenta: "\\x1b[35m",
  cyan: "\\x1b[36m"
};

// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const log = (msg) => console.log(msg);
const success = (msg) => log(\`\${C.green}âœ“\${C.reset} \${msg}\`);
const error = (msg) => log(\`\${C.red}âœ—\${C.reset} \${msg}\`);
const info = (msg) => log(\`\${C.cyan}â„¹\${C.reset} \${msg}\`);

// â”€â”€â”€ BANNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function banner() {
  console.log(\`
\${C.magenta}\${C.bright}
  ${name.toUpperCase()}
\${C.reset}\${C.dim}  ${description}\${C.reset}
\`);
}

// â”€â”€â”€ COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const commands = {
  help: {
    desc: "Show help message",
    run: showHelp
  },
  version: {
    desc: "Show version",
    run: () => log("1.0.0")
  }`;

    // Add custom commands
    commands.forEach(cmd => {
      code += `,
  "${cmd.name}": {
    desc: "${cmd.description || cmd.name}",
    run: ${cmd.handler || `() => log("${cmd.name} command")`}
  }`;
    });

    code += `
};

// â”€â”€â”€ HELP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showHelp() {
  banner();
  log(\`\${C.bright}COMMANDS:\${C.reset}\\n\`);
  for (const [name, cmd] of Object.entries(commands)) {
    log(\`  \${C.cyan}\${name.padEnd(12)}\${C.reset} \${cmd.desc}\`);
  }
  log("");
}

// â”€â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const args = process.argv.slice(2);
const command = args[0];
const commandArgs = args.slice(1);

if (!command || command === "help" || command === "--help" || command === "-h") {
  commands.help.run();
} else if (commands[command]) {
  commands[command].run(commandArgs);
} else {
  error(\`Unknown command: \${command}\`);
  log(\`\\nRun \${C.cyan}${name} help\${C.reset} for available commands.\\n\`);
}
`;

    return {
      type: "cli",
      name,
      files: [
        { path: `${name}.js`, content: code, executable: true },
        {
          path: "package.json",
          content: JSON.stringify({
            name,
            version: "1.0.0",
            description,
            type: "module",
            bin: { [name]: `./${name}.js` },
            scripts: { start: `node ${name}.js` }
          }, null, 2)
        }
      ]
    };
  }

  generateComponent(spec) {
    const { name = "Component", props = [], hooks = [], styled = false } = spec;

    let code = `// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name} Component
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import React${hooks.length > 0 ? `, { ${hooks.join(", ")} }` : ""} from "react";
${styled ? 'import styled from "styled-components";' : ""}

`;

    if (styled) {
      code += `const Container = styled.div\`
  padding: 1rem;
  border-radius: 8px;
  background: #f5f5f5;
\`;

`;
    }

    const propsInterface = props.length > 0
      ? `{ ${props.map(p => `${p.name}${p.required ? "" : "?"}`).join(", ")} }`
      : "";

    code += `export default function ${name}(${propsInterface ? `props` : ""}) {
  ${propsInterface ? `const ${propsInterface} = props;` : ""}
`;

    // Add hooks
    if (hooks.includes("useState")) {
      code += `  const [state, setState] = useState(null);
`;
    }
    if (hooks.includes("useEffect")) {
      code += `
  useEffect(() => {
    // Effect logic here
    return () => {
      // Cleanup
    };
  }, []);
`;
    }

    code += `
  return (
    ${styled ? "<Container>" : "<div>"}
      <h2>${name}</h2>
      {/* Component content */}
    ${styled ? "</Container>" : "</div>"}
  );
}

${name}.defaultProps = {
${props.filter(p => p.default !== undefined).map(p => `  ${p.name}: ${JSON.stringify(p.default)}`).join(",\n")}
};
`;

    return {
      type: "component",
      name,
      files: [{ path: `components/${name}.jsx`, content: code }]
    };
  }

  generateServer(spec) {
    const { name = "server", port = 3000, routes = [], middleware = [] } = spec;

    let code = `// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name.toUpperCase()} - Express Server
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import express from "express";
import cors from "cors";

const app = express();
const PORT = process.env.PORT || ${port};

// â”€â”€â”€ MIDDLEWARE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Request logging
app.use((req, res, next) => {
  console.log(\`[\${new Date().toISOString()}] \${req.method} \${req.path}\`);
  next();
});
`;

    middleware.forEach(mw => {
      code += `app.use(${mw});
`;
    });

    code += `
// â”€â”€â”€ ROUTES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Health check
app.get("/health", (req, res) => {
  res.json({ status: "ok", timestamp: new Date().toISOString() });
});
`;

    routes.forEach(route => {
      code += `
app.${route.method?.toLowerCase() || "get"}("${route.path}", async (req, res) => {
  try {
    ${route.handler || `res.json({ message: "${route.path}" });`}
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
`;
    });

    code += `
// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: "Not Found" });
});

// Error handler
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: err.message });
});

// â”€â”€â”€ START SERVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.listen(PORT, () => {
  console.log(\`ðŸš€ Server running on http://localhost:\${PORT}\`);
});

export default app;
`;

    return {
      type: "server",
      name,
      files: [
        { path: `${name}.js`, content: code },
        {
          path: "package.json",
          content: JSON.stringify({
            name,
            version: "1.0.0",
            type: "module",
            scripts: {
              start: `node ${name}.js`,
              dev: `nodemon ${name}.js`
            },
            dependencies: {
              express: "^4.18.2",
              cors: "^2.8.5"
            },
            devDependencies: {
              nodemon: "^3.0.1"
            }
          }, null, 2)
        }
      ]
    };
  }

  generateModel(spec) {
    const { name, fields = [], database = "sqlite" } = spec;

    const tableName = name.toLowerCase() + "s";

    let code = `-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ${name.toUpperCase()} Model
-- Generated by CODEMASTER FORGE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS ${tableName} (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
`;

    fields.forEach((field, i) => {
      const comma = i < fields.length - 1 ? "," : "";
      code += `  ${field.name} ${field.type.toUpperCase()}${field.required ? " NOT NULL" : ""}${field.unique ? " UNIQUE" : ""}${field.default ? ` DEFAULT ${field.default}` : ""}${comma}
`;
    });

    code += `  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_${tableName}_created ON ${tableName}(created_at);
`;

    return {
      type: "model",
      name,
      files: [{ path: `models/${name.toLowerCase()}.sql`, content: code }]
    };
  }

  generateTest(spec) {
    const { name, functions = [], framework = "node" } = spec;

    let code = `// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ${name} Tests
// Generated by CODEMASTER FORGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { test, describe, beforeEach, afterEach } from "node:test";
import assert from "node:assert";

describe("${name}", () => {
  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

`;

    functions.forEach(fn => {
      code += `  describe("${fn.name}", () => {
    test("should exist", () => {
      assert.ok(typeof ${fn.name} === "function");
    });

    test("should handle valid input", () => {
      // Add your test logic here
      assert.ok(true);
    });

    test("should handle edge cases", () => {
      // Add edge case tests here
      assert.ok(true);
    });
  });

`;
    });

    code += `});

console.log("Running ${name} tests...");
`;

    return {
      type: "test",
      name,
      files: [{ path: `tests/${name.toLowerCase()}.test.js`, content: code }]
    };
  }

  generateProject(spec) {
    const { name, type = "fullstack", features = [] } = spec;

    const files = [];

    // Package.json
    files.push({
      path: "package.json",
      content: JSON.stringify({
        name,
        version: "1.0.0",
        type: "module",
        scripts: {
          start: "node index.js",
          dev: "nodemon index.js",
          test: "node --test tests/",
          build: "echo 'Build step'"
        },
        dependencies: {},
        devDependencies: {}
      }, null, 2)
    });

    // README
    files.push({
      path: "README.md",
      content: `# ${name}

Generated by CODEMASTER FORGE

## Getting Started

\`\`\`bash
npm install
npm run dev
\`\`\`

## Features

${features.map(f => `- ${f}`).join("\n")}
`
    });

    // .gitignore
    files.push({
      path: ".gitignore",
      content: `node_modules/
.env
.env.local
dist/
.DS_Store
*.log
`
    });

    // Index file
    files.push({
      path: "index.js",
      content: `// ${name} - Entry Point
console.log("${name} starting...");
`
    });

    return {
      type: "project",
      name,
      files
    };
  }

  // â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  generateWranglerConfig(name, options = {}) {
    let config = `name = "${name}"
main = "workers/${name}.js"
compatibility_date = "2024-12-01"
`;

    if (options.kv) {
      config += `
kv_namespaces = [
  { binding = "KV", id = "YOUR_KV_NAMESPACE_ID" }
]
`;
    }

    if (options.ai) {
      config += `
[ai]
binding = "AI"
`;
    }

    return config;
  }

  getAvailableTemplates() {
    return Array.from(this.templates.entries()).map(([id, t]) => ({
      id,
      name: t.name,
      description: t.description
    }));
  }

  getHistory() {
    return this.history;
  }
}

// Helper
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

export default CodeForge;
