<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ§  GABRIEL BRAIN VISUALIZER | ZERO LATENCY</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: radial-gradient(ellipse at center, #0a0a12 0%, #000000 100%);
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 1px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.5rem;
            background: linear-gradient(90deg, #00ff88, #00ccff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 3s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 5px #00ff88); }
            50% { filter: drop-shadow(0 0 20px #00ccff); }
        }
        
        .stats {
            display: flex;
            gap: 30px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00ff88;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
        }
        
        /* CANVAS CONTAINER */
        #canvas-container {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        /* NODE INFO PANEL */
        .node-info {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 300px;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            display: none;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.2);
        }
        
        .node-info.active { display: block; }
        
        .node-info h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .node-type {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            margin-bottom: 10px;
        }
        
        .node-type.core { background: linear-gradient(135deg, #ff0066, #aa0044); }
        .node-type.system { background: linear-gradient(135deg, #0066ff, #0044aa); }
        .node-type.protocol { background: linear-gradient(135deg, #ffaa00, #aa6600); }
        .node-type.module { background: linear-gradient(135deg, #00ff88, #00aa55); }
        .node-type.portal { background: linear-gradient(135deg, #aa00ff, #6600aa); }
        
        .node-connections {
            margin-top: 15px;
            font-size: 0.85rem;
            color: #888;
        }
        
        .connection-item {
            padding: 5px 0;
            border-bottom: 1px solid #222;
        }
        
        /* LEGEND */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 30px;
            border: 1px solid #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .legend-dot.core { background: #ff0066; box-shadow: 0 0 10px #ff0066; }
        .legend-dot.system { background: #0066ff; box-shadow: 0 0 10px #0066ff; }
        .legend-dot.protocol { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .legend-dot.module { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
        .legend-dot.portal { background: #aa00ff; box-shadow: 0 0 10px #aa00ff; }
        
        /* LOADING */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #333;
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>ðŸ§  GABRIEL SYSTEM OMEGA - NEURAL VISUALIZER</h1>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="node-count">19</div>
                <div class="stat-label">Nodes</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="edge-count">35</div>
                <div class="stat-label">Edges</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="fps">60</div>
                <div class="stat-label">FPS</div>
            </div>
        </div>
    </header>
    
    <div id="canvas-container">
        <canvas id="brain-canvas"></canvas>
    </div>
    
    <div class="node-info" id="node-info">
        <h3 id="info-label">GABRIEL</h3>
        <span class="node-type core" id="info-type">CORE</span>
        <p id="info-desc" style="margin-top: 10px; color: #aaa;">Primary AI Orchestrator</p>
        <div class="node-connections">
            <strong>Connections:</strong>
            <div id="info-connections"></div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item"><span class="legend-dot core"></span>Core</div>
        <div class="legend-item"><span class="legend-dot system"></span>System</div>
        <div class="legend-item"><span class="legend-dot protocol"></span>Protocol</div>
        <div class="legend-item"><span class="legend-dot module"></span>Module</div>
        <div class="legend-item"><span class="legend-dot portal"></span>Portal</div>
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p>INITIALIZING NEURAL NETWORK...</p>
    </div>

    <script>
        // BRAIN DATA
        const BRAIN = {
            nodes: [
                {id: "gabriel", label: "GABRIEL", type: "core", desc: "Primary AI Orchestrator"},
                {id: "mc96", label: "MC96", type: "system", desc: "Mission Control 96"},
                {id: "omega", label: "OMEGA", type: "protocol", desc: "Ultimate Protocol Layer"},
                {id: "ecouniverse", label: "ECOUNIVERSE", type: "system", desc: "Ecosystem Universe"},
                {id: "voice", label: "VOICE", type: "module", desc: "Voice Processing"},
                {id: "vision", label: "VISION", type: "module", desc: "Visual Recognition"},
                {id: "memory", label: "MEMORY", type: "module", desc: "Persistent Memory Store"},
                {id: "shirl", label: "SHIRL", type: "core", desc: "Creative AI Core"},
                {id: "keith", label: "ENGR_KEITH", type: "core", desc: "Engineering AI Core"},
                {id: "deepseek", label: "DEEPSEEK R1", type: "protocol", desc: "Deep Reasoning Engine"},
                {id: "sonic", label: "SONIC-TEMPLATOR", type: "module", desc: "Audio Template System"},
                {id: "temporal", label: "TEMPORAL", type: "protocol", desc: "Time-Based Processing"},
                {id: "gorunfree", label: "GORUNFREE", type: "protocol", desc: "Freedom Protocol"},
                {id: "voiceforge", label: "VOICE FORGE", type: "module", desc: "Voice Synthesis Engine"},
                {id: "knowledge", label: "KNOWLEDGE GRAPH", type: "system", desc: "Knowledge Repository"},
                {id: "ailifeluv", label: "AI_LIFELUV", type: "core", desc: "Life & Love AI Core"},
                {id: "dreamchamber", label: "DREAMCHAMBER", type: "portal", desc: "Creative Dream Space"},
                {id: "infiniteenergy", label: "INFINITE ENERGY", type: "protocol", desc: "Unlimited Power Source"},
                {id: "mc96universe", label: "MC96UNIVERSE", type: "system", desc: "Universal Control Hub"}
            ],
            edges: [
                {from: "gabriel", to: "mc96"}, {from: "gabriel", to: "omega"},
                {from: "gabriel", to: "ecouniverse"}, {from: "gabriel", to: "voice"},
                {from: "gabriel", to: "vision"}, {from: "gabriel", to: "shirl"},
                {from: "gabriel", to: "keith"}, {from: "gabriel", to: "memory"},
                {from: "gabriel", to: "gorunfree"}, {from: "gabriel", to: "ailifeluv"},
                {from: "mc96", to: "memory"}, {from: "mc96", to: "temporal"},
                {from: "mc96", to: "knowledge"}, {from: "mc96", to: "mc96universe"},
                {from: "omega", to: "deepseek"}, {from: "omega", to: "temporal"},
                {from: "shirl", to: "voice"}, {from: "shirl", to: "voiceforge"},
                {from: "sonic", to: "voice"}, {from: "sonic", to: "voiceforge"},
                {from: "keith", to: "deepseek"}, {from: "keith", to: "knowledge"},
                {from: "ecouniverse", to: "knowledge"}, {from: "memory", to: "temporal"},
                {from: "ailifeluv", to: "infiniteenergy"}, {from: "ailifeluv", to: "dreamchamber"},
                {from: "dreamchamber", to: "shirl"}, {from: "dreamchamber", to: "keith"},
                {from: "mc96universe", to: "ailifeluv"}, {from: "infiniteenergy", to: "gorunfree"},
                {from: "infiniteenergy", to: "memory"}, {from: "infiniteenergy", to: "voice"},
                {from: "infiniteenergy", to: "vision"}, {from: "infiniteenergy", to: "knowledge"}
            ]
        };
        
        const COLORS = {
            core: '#ff0066',
            system: '#0066ff',
            protocol: '#ffaa00',
            module: '#00ff88',
            portal: '#aa00ff'
        };
        
        // FORCE-DIRECTED GRAPH ENGINE
        class NeuralVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.nodes = [];
                this.edges = [];
                this.selectedNode = null;
                this.hoveredNode = null;
                this.mouseX = 0;
                this.mouseY = 0;
                this.isDragging = false;
                this.dragNode = null;
                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mouseup', () => this.onMouseUp());
                canvas.addEventListener('click', (e) => this.onClick(e));
                
                this.init();
            }
            
            resize() {
                const container = document.getElementById('canvas-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            }
            
            init() {
                // Create node objects with physics
                const nodeMap = {};
                BRAIN.nodes.forEach((n, i) => {
                    const angle = (i / BRAIN.nodes.length) * Math.PI * 2;
                    const radius = 250 + Math.random() * 100;
                    const node = {
                        ...n,
                        x: this.centerX + Math.cos(angle) * radius,
                        y: this.centerY + Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: n.id === 'gabriel' ? 35 : 22,
                        connections: []
                    };
                    this.nodes.push(node);
                    nodeMap[n.id] = node;
                });
                
                // Create edge objects
                BRAIN.edges.forEach(e => {
                    const from = nodeMap[e.from];
                    const to = nodeMap[e.to];
                    if (from && to) {
                        this.edges.push({ from, to });
                        from.connections.push(to.label);
                        to.connections.push(from.label);
                    }
                });
                
                document.getElementById('loading').style.display = 'none';
                this.animate();
            }
            
            applyForces() {
                // Repulsion between all nodes
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const n1 = this.nodes[i];
                        const n2 = this.nodes[j];
                        const dx = n2.x - n1.x;
                        const dy = n2.y - n1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 3000 / (dist * dist);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        n1.vx -= fx;
                        n1.vy -= fy;
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
                
                // Attraction along edges
                this.edges.forEach(e => {
                    const dx = e.to.x - e.from.x;
                    const dy = e.to.y - e.from.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = (dist - 150) * 0.01;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    e.from.vx += fx;
                    e.from.vy += fy;
                    e.to.vx -= fx;
                    e.to.vy -= fy;
                });
                
                // Center gravity
                this.nodes.forEach(n => {
                    const dx = this.centerX - n.x;
                    const dy = this.centerY - n.y;
                    n.vx += dx * 0.001;
                    n.vy += dy * 0.001;
                });
                
                // Apply velocities with damping
                this.nodes.forEach(n => {
                    if (n !== this.dragNode) {
                        n.vx *= 0.85;
                        n.vy *= 0.85;
                        n.x += n.vx;
                        n.y += n.vy;
                        
                        // Bounds
                        n.x = Math.max(50, Math.min(this.canvas.width - 50, n.x));
                        n.y = Math.max(50, Math.min(this.canvas.height - 50, n.y));
                    }
                });
            }
            
            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges
                this.edges.forEach(e => {
                    const isHighlighted = this.hoveredNode && 
                        (e.from === this.hoveredNode || e.to === this.hoveredNode);
                    
                    ctx.beginPath();
                    ctx.moveTo(e.from.x, e.from.y);
                    ctx.lineTo(e.to.x, e.to.y);
                    ctx.strokeStyle = isHighlighted ? '#00ff88' : 'rgba(100, 100, 100, 0.3)';
                    ctx.lineWidth = isHighlighted ? 2 : 1;
                    ctx.stroke();
                    
                    // Animated particles on highlighted edges
                    if (isHighlighted) {
                        const t = (Date.now() % 2000) / 2000;
                        const px = e.from.x + (e.to.x - e.from.x) * t;
                        const py = e.from.y + (e.to.y - e.from.y) * t;
                        ctx.beginPath();
                        ctx.arc(px, py, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#00ff88';
                        ctx.fill();
                    }
                });
                
                // Draw nodes
                this.nodes.forEach(n => {
                    const isHovered = n === this.hoveredNode;
                    const color = COLORS[n.type];
                    const radius = isHovered ? n.radius * 1.3 : n.radius;
                    
                    // Glow
                    const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, radius * 2);
                    gradient.addColorStop(0, color + '40');
                    gradient.addColorStop(1, 'transparent');
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Node circle
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = isHovered ? color : color + 'cc';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = isHovered ? 3 : 1;
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = `${isHovered ? 'bold ' : ''}${isHovered ? 12 : 10}px "SF Mono", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(n.label, n.x, n.y + radius + 15);
                });
                
                // FPS
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsTime >= 1000) {
                    document.getElementById('fps').textContent = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                }
            }
            
            animate() {
                this.applyForces();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
            
            getNodeAt(x, y) {
                return this.nodes.find(n => {
                    const dx = x - n.x;
                    const dy = y - n.y;
                    return Math.sqrt(dx * dx + dy * dy) < n.radius;
                });
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseX = e.clientX - rect.left;
                this.mouseY = e.clientY - rect.top;
                
                if (this.dragNode) {
                    this.dragNode.x = this.mouseX;
                    this.dragNode.y = this.mouseY;
                    this.dragNode.vx = 0;
                    this.dragNode.vy = 0;
                } else {
                    this.hoveredNode = this.getNodeAt(this.mouseX, this.mouseY);
                    this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'default';
                }
            }
            
            onMouseDown(e) {
                const node = this.getNodeAt(this.mouseX, this.mouseY);
                if (node) {
                    this.dragNode = node;
                    this.isDragging = true;
                }
            }
            
            onMouseUp() {
                this.dragNode = null;
                this.isDragging = false;
            }
            
            onClick(e) {
                const node = this.getNodeAt(this.mouseX, this.mouseY);
                if (node) {
                    this.showNodeInfo(node);
                } else {
                    document.getElementById('node-info').classList.remove('active');
                }
            }
            
            showNodeInfo(node) {
                const panel = document.getElementById('node-info');
                document.getElementById('info-label').textContent = node.label;
                document.getElementById('info-desc').textContent = node.desc;
                
                const typeEl = document.getElementById('info-type');
                typeEl.textContent = node.type.toUpperCase();
                typeEl.className = 'node-type ' + node.type;
                
                const connEl = document.getElementById('info-connections');
                connEl.innerHTML = node.connections.map(c => 
                    `<div class="connection-item">â†’ ${c}</div>`
                ).join('');
                
                panel.classList.add('active');
            }
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('brain-canvas');
            new NeuralVisualizer(canvas);
        });
    </script>
</body>
</html>
