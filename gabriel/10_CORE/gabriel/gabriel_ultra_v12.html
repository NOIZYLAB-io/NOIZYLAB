<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GABRIEL // ULTRA v12.0</title>
    <style>
        /* --- 1. THE FLUID STYLE SYSTEM --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'SF Pro Display', 'Helvetica Neue', sans-serif;
            user-select: none;
            cursor: crosshair;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD OVERLAY */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        /* GLASS PANELS */
        .glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            pointer-events: auto;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                box-shadow 0.3s ease,
                border-color 0.3s ease;
        }

        .glass:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 40px rgba(0, 255, 204, 0.15);
            border-color: rgba(0, 255, 204, 0.5);
        }

        /* HEADER */
        .header {
            align-self: flex-start;
        }

        .header h1 {
            margin: 0;
            color: #FFF;
            font-weight: 200;
            letter-spacing: 6px;
            font-size: 28px;
        }

        .header .status {
            color: #00FFCC;
            font-size: 10px;
            letter-spacing: 3px;
            margin-top: 8px;
            text-transform: uppercase;
        }

        .header .version {
            color: #666;
            font-size: 9px;
            letter-spacing: 2px;
            margin-top: 4px;
        }

        /* CIRCULAR VISUALIZER */
        #visualizer-ring {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: rgba(0, 0, 0, 0.5);
        }

        #visualizer-ring:hover {
            border-color: #00FFCC;
            box-shadow: 0 0 40px rgba(0, 255, 204, 0.2);
            transform: translateX(-50%) scale(1.1);
        }

        #mic-icon {
            width: 24px;
            height: 24px;
            background: #FFF;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        #visualizer-ring.active {
            border-color: #00FFCC;
            box-shadow: 0 0 60px rgba(0, 255, 204, 0.4);
        }

        #visualizer-ring.active #mic-icon {
            background: #00FFCC;
            box-shadow: 0 0 30px #00FFCC;
        }

        #visualizer-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 10px;
            letter-spacing: 3px;
            pointer-events: none;
        }

        /* CONTROLS */
        .control-panel {
            width: 280px;
            align-self: flex-end;
        }

        .control-panel h3 {
            color: #666;
            font-size: 10px;
            letter-spacing: 3px;
            margin-bottom: 15px;
            font-weight: 400;
        }

        button {
            background: transparent;
            border: none;
            color: #888;
            width: 100%;
            text-align: left;
            padding: 12px 0;
            cursor: pointer;
            transition: all 0.25s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-family: inherit;
            font-size: 13px;
            letter-spacing: 1px;
        }

        button:hover {
            color: #FFF;
            padding-left: 15px;
            border-bottom-color: rgba(0, 255, 204, 0.3);
        }

        /* TEXT INPUT */
        #text-input-container {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            pointer-events: auto;
        }

        #text-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #FFF;
            padding: 16px 20px;
            font-family: inherit;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        #text-input:focus {
            border-color: #00FFCC;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.2);
        }

        #text-input::placeholder {
            color: #555;
        }

        /* RESPONSE BOX */
        #response-box {
            position: absolute;
            top: 50%;
            right: 60px;
            transform: translateY(-50%);
            width: 350px;
            max-height: 300px;
            overflow-y: auto;
            pointer-events: auto;
            display: none;
        }

        #response-box.active {
            display: block;
            animation: slideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        #response-content {
            color: #CCC;
            font-size: 14px;
            line-height: 1.8;
        }

        /* FPS COUNTER */
        #fps-counter {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #444;
            font-size: 10px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
    { "imports": { 
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", 
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" 
    }}
    </script>
</head>

<body>

    <div id="fps-counter">60 FPS</div>

    <div id="hud">
        <div class="header glass">
            <h1>GABRIEL</h1>
            <div class="status" id="status">INITIALIZING...</div>
            <div class="version">ULTRA INTERFACE v12.0</div>
        </div>

        <div class="control-panel glass">
            <h3>CONTROLS</h3>
            <button id="btn-reset">⟲ RESET CAMERA</button>
            <button id="btn-lights">◐ TOGGLE STUDIO LIGHTS</button>
            <button id="btn-debug">⚙ DEBUG OVERLAY</button>
        </div>

        <div id="visualizer-ring">
            <div id="mic-icon"></div>
        </div>
        <div id="visualizer-label">CLICK TO SPEAK</div>

        <div id="text-input-container">
            <input type="text" id="text-input" placeholder="Or type your message..." autocomplete="off" />
        </div>

        <div id="response-box" class="glass">
            <div id="response-content"></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ========== 1. PHYSICS STATE ==========
        const mouse = { x: 0, y: 0 };
        const targetMouse = { x: 0, y: 0 };
        let isConnected = false;
        let frameCount = 0, lastTime = performance.now(), fps = 60;

        // ========== 2. SCENE SETUP ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x030303);
        scene.fog = new THREE.Fog(0x030303, 4, 12);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.5, 3);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ========== 3. LIGHTING ==========
        const ambientLight = new THREE.AmbientLight(0x111111);
        scene.add(ambientLight);

        const keyLight = new THREE.SpotLight(0x00FFCC, 15);
        keyLight.position.set(4, 4, 4);
        keyLight.angle = Math.PI / 5;
        keyLight.penumbra = 0.5;
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);

        const fillLight = new THREE.PointLight(0xFF00FF, 4);
        fillLight.position.set(-4, 1, 4);
        scene.add(fillLight);

        const rimLight = new THREE.SpotLight(0x0066FF, 8);
        rimLight.position.set(0, 2, -4);
        scene.add(rimLight);

        // Ground
        const groundGeom = new THREE.PlaneGeometry(30, 30);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x050505,
            metalness: 0.9,
            roughness: 0.3
        });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ========== 4. AVATAR ==========
        let avatar, neckBone, mouthMesh;
        const loader = new GLTFLoader();

        loader.load('https://models.readyplayer.me/64b772c085002958742f36e4.glb', (gltf) => {
            avatar = gltf.scene;
            avatar.position.y = 0;
            scene.add(avatar);

            avatar.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                    if (o.morphTargetDictionary?.mouthOpen) mouthMesh = o;
                }
                if (o.isBone && o.name === 'Neck') neckBone = o;
            });

            document.getElementById('status').innerText = 'READY';
            document.getElementById('status').style.color = '#00FFCC';
        });

        // ========== 5. WEBSOCKET ==========
        let socket, audioCtx, analyser, dataArray;
        let mouthOpenValue = 0;

        function connect() {
            socket = new WebSocket('ws://localhost:8000/ws/gabriel');

            socket.onopen = () => {
                isConnected = true;
                document.getElementById('status').innerText = 'ONLINE';
            };

            socket.onmessage = async (event) => {
                try {
                    // Try JSON first (text mode)
                    const data = JSON.parse(event.data);
                    if (data.type === 'response') {
                        document.getElementById('response-content').innerHTML = data.content.replace(/\n/g, '<br>');
                        document.getElementById('response-box').classList.add('active');
                        animateSpeech(data.content.length * 20);
                    }
                } catch (e) {
                    // Binary audio data
                    if (audioCtx) {
                        const buffer = await event.data.arrayBuffer();
                        audioCtx.decodeAudioData(buffer, (audio) => {
                            const source = audioCtx.createBufferSource();
                            source.buffer = audio;
                            source.connect(analyser);
                            source.connect(audioCtx.destination);
                            source.start(0);
                        });
                    }
                }
            };

            socket.onclose = () => {
                isConnected = false;
                document.getElementById('status').innerText = 'OFFLINE';
                document.getElementById('status').style.color = '#FF0000';
                setTimeout(connect, 3000);
            };
        }

        function sendText(text) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'text', content: text }));
            }
        }

        function animateSpeech(duration) {
            const start = Date.now();
            function speak() {
                const elapsed = Date.now() - start;
                if (elapsed < duration) {
                    mouthOpenValue = Math.sin(elapsed * 0.025) * 0.4 + 0.3 + Math.random() * 0.1;
                    requestAnimationFrame(speak);
                } else {
                    mouthOpenValue = 0;
                }
            }
            speak();
        }

        // ========== 6. VOICE ACTIVATION ==========
        document.getElementById('visualizer-ring').addEventListener('click', async () => {
            if (!isConnected) connect();

            document.getElementById('visualizer-ring').classList.add('active');
            document.getElementById('visualizer-label').innerText = 'LISTENING...';

            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioCtx.createMediaStreamSource(stream);
            const processor = audioCtx.createScriptProcessor(4096, 1, 1);
            source.connect(processor);
            processor.connect(audioCtx.destination);

            processor.onaudioprocess = (e) => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    const input = e.inputBuffer.getChannelData(0);
                    const pcm = new Int16Array(input.length);
                    for (let i = 0; i < input.length; i++) {
                        pcm[i] = Math.min(1, Math.max(-1, input[i])) * 0x7FFF;
                    }
                    socket.send(pcm);
                }
            };
        });

        // ========== 7. TEXT INPUT ==========
        document.getElementById('text-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const input = e.target;
                if (input.value.trim()) {
                    if (!isConnected) connect();
                    setTimeout(() => sendText(input.value), 100);
                    input.value = '';
                }
            }
        });

        // ========== 8. MOUSE TRACKING ==========
        window.addEventListener('mousemove', (e) => {
            targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // ========== 9. RENDER LOOP (60FPS PHYSICS) ==========
        function animate() {
            requestAnimationFrame(animate);

            // FPS Counter
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps-counter').innerText = `${fps} FPS`;
                frameCount = 0;
                lastTime = now;
            }

            // SMOOTH MOUSE LERP (Creates inertia)
            mouse.x += (targetMouse.x - mouse.x) * 0.05;
            mouse.y += (targetMouse.y - mouse.y) * 0.05;

            // PARALLAX CAMERA
            camera.position.x = mouse.x * 0.6;
            camera.position.y = 1.5 + (mouse.y * 0.25);
            camera.lookAt(0, 1.35, 0);

            // AVATAR NECK TRACKING
            if (neckBone) {
                neckBone.rotation.y = THREE.MathUtils.lerp(neckBone.rotation.y, mouse.x * 0.4, 0.08);
                neckBone.rotation.x = THREE.MathUtils.lerp(neckBone.rotation.x, -mouse.y * 0.2, 0.08);
            }

            // LIP SYNC
            if (mouthMesh && mouthMesh.morphTargetDictionary) {
                const idx = mouthMesh.morphTargetDictionary.mouthOpen;
                if (idx !== undefined) {
                    const current = mouthMesh.morphTargetInfluences[idx];
                    mouthMesh.morphTargetInfluences[idx] = THREE.MathUtils.lerp(current, mouthOpenValue, 0.35);
                }
            }

            // VISUALIZER PULSE
            if (analyser && isConnected) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                const vol = sum / dataArray.length;

                const scale = 1 + (vol / 80);
                document.getElementById('mic-icon').style.transform = `scale(${scale})`;

                // Also animate mouth from audio
                mouthOpenValue = Math.min(1, vol / 40);
            }

            // SUBTLE LIGHT ANIMATION
            keyLight.position.x = 4 + Math.sin(now * 0.0003) * 0.5;
            fillLight.position.z = 4 + Math.cos(now * 0.0004) * 0.3;

            renderer.render(scene, camera);
        }
        animate();

        // ========== 10. RESIZE ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Auto-connect
        setTimeout(connect, 500);
    </script>
</body>

</html>