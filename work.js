global.IS_ECHOAPI=!0;const path=require("path"),{parentPort}=require("worker_threads"),{run,request2HAR}=require(path.join(__dirname,"runtime","index.js"));class PromiseQueue{queue=Promise.resolve(!0);add(e){return new Promise(((t,r)=>{this.queue=this.queue.then(e).then(t).catch(r)}))}get(){return this.queue}}const runPromise=(e,t)=>new Promise((async(r,s)=>{try{await run(t,e,(e=>{r(e)}))}catch(e){s(e)}})),methods={httpSend:async(e,t)=>{let r=await runPromise(e,t);return JSON.stringify(r)},runnerEvent:async(e,t,r)=>{await run(t,e,r)},httpHar:async(e,t)=>{const r=await request2HAR(t,e);return r||null}};parentPort.on("message",(async e=>{const{method:t,args:r}=e;if(methods[t])try{if("runnerEvent"===t){const e=new PromiseQueue;return await methods[t](...r,(t=>{e.add((async()=>{"string"==typeof t?parentPort.postMessage(t):parentPort.postMessage(JSON.stringify(t))}))})),void await e.get()}const e=await methods[t](...r);parentPort.postMessage(e)}catch(e){parentPort.postMessage(e.message)}else parentPort.postMessage(`Unknown method: ${t}`)}));