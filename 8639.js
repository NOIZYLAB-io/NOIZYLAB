"use strict";exports.id=8639,exports.ids=[8639],exports.modules={418639:(P,A,s)=>{s.d(A,{fromHttp:()=>K});var C=s(313421),l=s(986895),i=s(966653),I=s(191943),E=s.n(I);const k="127.0.0.0/8",D="::1/128",N="169.254.170.2",u="169.254.170.23",R="[fd00:ec2::23]",m=(e,n)=>{if(e.protocol!=="https:"&&!(e.hostname===N||e.hostname===u||e.hostname===R)){if(e.hostname.includes("[")){if(e.hostname==="[::1]"||e.hostname==="[0000:0000:0000:0000:0000:0000:0000:0001]")return}else{if(e.hostname==="localhost")return;const o=e.hostname.split("."),r=t=>{const a=parseInt(t,10);return 0<=a&&a<=255};if(o[0]==="127"&&r(o[1])&&r(o[2])&&r(o[3])&&o.length===4)return}throw new i.C(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,{logger:n})}};var g=s(644815),O=s(444635),S=s(400910);function f(e){return new g.K({protocol:e.protocol,hostname:e.hostname,port:Number(e.port),path:e.pathname,query:Array.from(e.searchParams.entries()).reduce((n,[o,r])=>(n[o]=r,n),{}),fragment:e.hash})}async function w(e,n){const r=await(0,S.c)(e.body).transformToString();if(e.statusCode===200){const t=JSON.parse(r);if(typeof t.AccessKeyId!="string"||typeof t.SecretAccessKey!="string"||typeof t.Token!="string"||typeof t.Expiration!="string")throw new i.C("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",{logger:n});return{accessKeyId:t.AccessKeyId,secretAccessKey:t.SecretAccessKey,sessionToken:t.Token,expiration:(0,O.EI)(t.Expiration)}}if(e.statusCode>=400&&e.statusCode<500){let t={};try{t=JSON.parse(r)}catch{}throw Object.assign(new i.C(`Server responded with status: ${e.statusCode}`,{logger:n}),{Code:t.Code,Message:t.Message})}throw new i.C(`Server responded with status: ${e.statusCode}`,{logger:n})}const p=(e,n,o)=>async()=>{for(let r=0;r<n;++r)try{return await e()}catch{await new Promise(a=>setTimeout(a,o))}return await e()},v="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",L="http://169.254.170.2",_="AWS_CONTAINER_CREDENTIALS_FULL_URI",y="AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",U="AWS_CONTAINER_AUTHORIZATION_TOKEN",K=(e={})=>{e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");let n;const o=e.awsContainerCredentialsRelativeUri??process.env[v],r=e.awsContainerCredentialsFullUri??process.env[_],t=e.awsContainerAuthorizationToken??process.env[U],a=e.awsContainerAuthorizationTokenFile??process.env[y],c=e.logger?.constructor?.name==="NoOpLogger"||!e.logger?.warn?console.warn:e.logger.warn.bind(e.logger);if(o&&r&&(c("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."),c("awsContainerCredentialsFullUri will take precedence.")),t&&a&&(c("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."),c("awsContainerAuthorizationToken will take precedence.")),r)n=r;else if(o)n=`${L}${o}`;else throw new i.C(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,{logger:e.logger});const T=new URL(n);m(T,e.logger);const H=l.$.create({requestTimeout:e.timeout??1e3,connectionTimeout:e.timeout??1e3});return p(async()=>{const d=f(T);t?d.headers.Authorization=t:a&&(d.headers.Authorization=(await E().readFile(a)).toString());try{const h=await H.handle(d);return w(h.response).then(F=>(0,C.g)(F,"CREDENTIALS_HTTP","z"))}catch(h){throw new i.C(String(h),{logger:e.logger})}},e.maxRetries??3,e.timeout??1e3)}}};
